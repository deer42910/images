## Java

String类(不可变类)：final 为什么 ？1.string常作为密码啥的不能修改 2.final与native有关，它是linux系统的，肯定不能随意修改

stringBuffer线程安全 他是动态数组 存在的意义就是方便修改String 因为String每次创建都要创建一个新的类，占用空间

类加载 过程 

1.加载(将.class文件加载到jvm的方法区(保存类的数据结构[类里边有什么：成员变量，构造方法，方法，静态方法等等] [对象在堆中])  

2.连接

- 检查：class文件格式是否符和，

  ​             对字节码描述的信息进行语义分析是否符号Java语言规范（看这个类有没有父类），

  ​             符号引用验证：确保解析动作正确执行

- 准备：为静态变量分配内存，并将其初始化为默认值0

- 解析：把类中的符号引用转换为直接引用

3.初始化：静态变量赋值，[分配空间，调用构造函数，初始化成员变量，调用父类构造函数，执行初始化块，执行构造函数体]

> 双亲委派机制是在类加载过程中，当一个类加载收到类加载请求时，它不会立即去加载这个类，而是先委托它的父类加载器去加载。只有当父类加载器无法加载改类时，子类加载器才会去尝试自己加载。

为啥要先加载父类：

1.安全性[我们不能自定义java.lang.String类来替换系统提供的String类，因为系统类加载器会优先加载这些类]

2.同一个类在不同类加载中会被加载一次。

List 

Zset 排行榜 ：怎么实现？将时间戳设置为score参数，在用range命令获取  

为什么使用zset 不能重复且有序

基本数据类型和包装类：   包装类：用于泛型 集合中必需使用包装流

int为啥存在：占用空间小，不可变的就是不用new，方便转化为String类，集合不能为null

线程 四种方式        有返回值，是用futurn的get()接收的

线程池的7个参数  ： 

1. 核心线程数：主要执行任务的数量  
2. 最大线程数：核心线程+救急线程的最大数目
3. 生存时间：救急线程的最大生存时间
4. 时间单位：
5. 工作线程：没有空闲的核心线程时，新来的任务就会加入到此队列排序
6.  线程工厂:创建线程对象
7. 拒绝策略：就是工作线程满了，我们应该是直接删除还是，删除不常使用的等等策略

常用的线程池：

1. 单线程化的线程池(newSingleThreadExecutor())按顺序进行	
2. 可缓存线程池newCacheThreadExceptor():灵活回收线程， 
3. 固定线程数的线程池newFixed...控制线程最大并发数

线程与进程：1.线程是正在执行的实例，进程中包含了线程，每个线程执行不同得任务 2.不同进程使用不同得内存空间，当前进程下得所有线程共享工作空间 3.线程上下文切换一般比进程上下文切换成本低

并发：抢占CPU ，多个线程轮流使用一个或多个CPU

并行：同一时间，4核CPU同时执行4个线程





​    线程允许得**状态**：新建：创建线程对象、可运行调用了start()方法转变为可运行、阻塞(没有得到锁)、等待(wait()或sleep())、时间等待(sleep(1000))、终止(线程执行结束) 

​     如何让线程**中断**：在sleep()或wait()时中断线程，就会抛出线程异常，手动中断线程；利用if判断是否中断，中断就删除；stop() 已经废除；System.exit()

​    让线程按顺序进行：在线程2中加入t1.join() 等待线程1执行结束后，加入

​    volatile:1.可见性：被他修饰的共享变量，让一个线程对共享变量的修改对另一个变量可见

​                 2.指令重排：例子： 有一个变量value 另一个变量v  一个方法init{value=42 ；v=true}  另一个方法readvalue{if(v){sout:value}}   当有一个对象调用init方法 并且调用readvalue；编译器把他重排序倒过来，我们就无法保证if语句执行的时候value已经被赋值   所以我们要给他设置volatile修饰符，让value必需在v=true之前执行。

乐观锁：

防止超卖问题，

​    我们在扣减库存之间查询数据库判断库存是否>0  

​    还有一个是版本号控制，修改过的版本号和为修改的版本号不同

悲观锁：

synchronized（jvm中，C++语言实现；同步代码块锁会自动释放）

> 同步方法  同步代码块 

和Lock（jdk接口 unlock()释放锁）

> 接口更灵活还支持多种类型[可重入锁，读写锁] Lock lock = new ReentrantLock()[这个是可重入锁]  加锁lock.lock()  释放锁lock.unlock()

并发，volatlie 锁 线程 线程池 

**反射**：获取类对象 Class.dorName("全类名")  类加载阶段 类名.class  运行阶段 对象.class() 获取类对象

利用newInstance()方法实例化对象[动态创建类对象]，前提是类必须由一个无参构造器而且构造器的访问权限必须足够。有参构造器就要用getConstructor方法，暴力打开访问权限用setAccessible(true)；调用方法使用invoke();

> 1.加载数据库驱动 Class.forName("com.mysql.cj.jdbc.Driver");  
>
> 2.在项目中，通过反射获取泛型类型
>
> ```
> 泛型 ：类型擦除，运行时，所有关于泛型类型的实际信息都会丢失。这意味着，通过反射获取到的对象或方法的信息将不会包含泛型信息。
> 
> 泛型的作用：
> 
> 1.提高代码的重用率；比如：List<T> a = new List<>();可以存储任何类型元素的列表，同时保持类型安全
> 
> 泛型的上下文：
> ```
>
> 3.动态代理：



## 数据结构

> 数组、链表、栈、队列、

**平衡二叉树**

```
1.左右两个子数高度差绝对值不能超过1
2.左右都是一个平衡二叉树
```

## Java基础

**深拷贝浅拷贝**

```
浅拷贝：只复制对象本身和其内部的值类型字段，不复制 对象内部 的引用类型对象
深拷贝的三种实现方法：
1.实现Cloneable接口并重写clone()方法 利用递归克隆引用类型字段来实现深拷贝
2.使用序列化反序列化 将对象序列化为字节流，再从字节流反序列化为对象来实现深拷贝。所以引用类型字段都实现序列化接口
3.手动递归复制 
return new Person(name,new Date(birthday.getTime()))
```

**泛型**

```
主要目的是在编译时提供更强的类型检查，并且编译后能够保留类型信息，避免在运行时出现类型转换错误
1.适用于多种数据类型执行相同的代码
2.泛型中类型在使用时指定，不需要强制类型装换(线程安全，编译器会检查类型)
```

**反射**：动态获取的信息以及动态调用对象的方法的功能；

```
1.运行时类信息访问
2.动态对象创建
3.动态方法调用
4.访问和修改字段值
```

反射的应用场景

```
1.加载数据库驱动 Class.forName("com.mysql.cj.jdbc.Driver");  
2.配置文件加载：IOC容器(动态管理Bean)，Spring通过配置文件配置各种各样的bean,你需要用到哪些bean就配哪些，spring容器根据你的需求去动态加载。
```



## 集合

ArrayList与LinkedList的区别

```
1.底层数据结构：动态数组 双向链表
2.查询，增删效率 索引查1，元素查n，新增设计到扩容n(把后面的数据后移)  插入只需要改变指证的指向，不需要移动元素，但还是需要找到该元素位置n 
3.是否支持随机访问 arrayList基于数组，实现了RandomAccass接口，可以通过下标获取元素；Linked不能
4.内存占用 arraylist开始是0第一次赋值为10，每次扩容1.5倍，都要重新分配内存  Linked是节点占用内存大
```

**ArrayList如何扩容**

```
首先判断是否需要扩容，当前容量+1超过数组长度，就要进行扩容，扩容后长度是原来的1.5倍，将原数组的值copy到新数组中
```

**ArrayLIst怎么序列化知道吗？为什么用transient**

```
它使用transient[暂存|缓存]修饰存储元素的elementData数组,让被transient修饰的成员属性不被系列化，[与这个无关：开始为空，当添加第一个元素时扩展为默认容量10]
为什么ArrayList不直接序列化元素数组呢？出于效率考虑，数组长度可能是100，实际只用例50，剩下的50不用序列化，节省空间，提高效率。
ArrayList通过readObject和writeObject
```

![image-20241025152846137](C:\Users\ASUS\Documents\面试题.assets\image-20241025152846137.png)

**序列化反序列化**

```
序列化：Java对象转换成字节流，以便保存到文件、数据库或者在网络上传输，使用ObjectOutputStream的writeObject()方法将对象写入到输出流中。
反序列化：就是将字节流重新返回Java对象；使用ObjectInputStream的readObject()方法从输入流中读取对象。
持久化（保存到硬盘）远程通信（网络上传输）深拷贝（赋值所有状态信息包括对象的引用）
```

**实现ArrayList线程安全的方法**

```
1.Collections.synchronizedList()方法 内部就是通过加锁实现
2.CopyOnWriteArrayList线程安全版本的ArrayList，采用读写分离的并发策略，读操作无锁，性能高，写操作是先将数据复制一份，在新副本上执行写操作，结束之后，再将原容器指向新容器
```

**CopyOnWriteArrayList如何实现线程安全**

> 共享读(不加锁)，排他写

```
1.底层也是通过一个数组保存数据，使用volatile关键字修饰数组，保证当前线程对数组对象重新赋值后，其他线程可以即时看到
   private transient volitile Object[] array;
2.在写操作时，加了一把互斥锁ReentrantLock以保证线程安全。
  //获取锁
  final ReentrantLock lock = this.lock;
  //加锁
  lock.lock();
  
  //写入新元素，首先获取到当前List集合保存的数据的数组，获取该数组长度；创建一个新的数组拷贝原数组的同时长度+1；加入元素放在新数组最后一位；最后替换引用，将数组引用指向给新数组的地址
  
  //释放锁
  lock.unlock();
```

**HashMap的底层数据结构**()

```
数组+链表+红黑树
数组存储键值对(Node[] table),数组中的每个值被称为“桶”，每个桶的索引通过对哈希值进行hash()[取模]处理得到；多个键经过哈希处理后得到相同的索引时，就需要用链表来解决哈希冲突，链表过长查询效率也低，链表长度>8(且数组大于64)转变为红黑树。n-logn  当红黑树结点个数小于6就变为链表
```

**HashMap的put过程介绍一下**

```
1.根据添加的键的哈希值计算在数组中的位置(索引)
2.检查该位置是否为空(即没有键值对存在)
   若为空，直接在该位置创建一个新的Entry对象来存储键值对。将要添加的键值对作为该Entry的键和值，并保存在数组的对应位置。将HashMap的修改次数(modCount)加1，以便在进行迭代时发现并发修改。
3.不为空，检查该位置的第一个键值对的哈希值和键是否与要添加的键值对相同？
   若相同，则表示找到相同的键，直接将新的值替换旧的值，完成更新操作
4.若不同，遍历链表或红黑树查找是否有相同的键
   若键值对集合是链表结构，从链表的头部开始逐个比较键的哈希值和equals()方法，直到找到相同的键或者达到链表末尾[若有相同键，使用新的替换旧的即更新键对应的值；若没相同的键，则将新的键值对添加到链表的头部]
   若是红黑树结构，在红黑树中使用哈希值和equals()方法进行查找。根据key的哈希值，定位到红黑树中的某个节点，然后逐个比较键，直到找到相同的键或者达到末尾[有相同的更新，没相同的，添加到红黑树]
5.检查链表长度是否达到阈值(默认为8)
   若超过阈值且数组长度大于等于64,链表转换为红黑树，提高查询效率
6.检查负载因子知否超过阈值(默认0.75)
  若键值对的数量(size)与数组长度的比值大于阈值0.75，则要进行扩容操作
7.扩容操作
  1、创建一个新的 两 倍大小的数组 2、将旧数组中的键值对重新计算哈希码并分配到新数组的位置 3、更新hashMap的数组引用和阈值参数
8.完成添加操作
  非线程安全，安全使用ConcurrentHashMap
```

**Hashtable与hashMap**:Java集合框架

```
hashtable:
1.线程安全，所有方法都是同步的；多个线程访问Hashtable而不会导致数据不一致的问题
2.不允许null键和null值：抛异常NullPointerException 
3.性能低：所有方法同步，同步开销大(加锁放锁)
hashMap:
1.线程不安全:多线程同时执行put操作，若计算出来的索引位置是相同的，那会造成前一个key被后一个key覆盖，从而导致元素丢失。
2.可以有一个null键和多个null值
3.性能好
```

**HashMap和equal方法不当会出现什么情况？**

```
1.重写equals方法，不重写hashCode方法，可能会出现equals方法返回为true,而hashCode方法却返回false
会导致在hashmap等类中存储多个一模一样的对象。
因为hashCode相等的两个对象，equals不一定相等(哈希冲突)；而equals相等的两个对象，hashCode一定相等。
```

**红黑树**

```
1.结点要么是黑要么是红2.根节点永远是黑且为null3.红色结点的子节点一定是黑色的4.从任一节点到每个叶子节点每个简路径都是相同的；
  为啥不用二叉树 有最坏情况，串联起来效率差
  为啥不用平衡二叉树，平衡二叉树，左右子树高度最多相差 1，为保证这种平衡，插入和删除需要自旋压力大，所以选择红黑树
  两种方式：旋转（左旋与右旋）和染色
```





**spring介绍**

```
IOC容器：spring通过控制反转实现了对象的创建和对象间的依赖关系管理，开发者只需要定义好Bean及其依赖关系，spring负责创建和组装这些对象；
AOP：面向切面编程，能够将那些与业务无关，却为业务模块所共同调用的逻辑封装起来，减少重复代码，降低模块间的耦合性
事务管理：提供了一致的事务管理接口，声明式和编程式事务，开发者无需关心事务具体API，轻松进行事务管理
MVC框架：模型-视图-控制器：它支持灵活的URL到页面控制器的映射，以及多种视图技术
```

IOC和**AOP通过什么机制实现**

```
IOC:
反射：动态的创建类，创建对象实例以及调用方法，反射允许在创建时获取类、属性、方法等。
依赖注入：将依赖关系写在配置文件中，通过函数等方法注入
设计模式-工厂模式：管理Bean对象的创建和生命周期， 
容器：通常使用BeanFactory与ApplicationContext管理类
AOP：
动态代理技术：不是在编程阶段，而允许在运行时指定要代理的类或方法，就可以不动源码的情况下增强方法功能
  JDK（基于接口）:实现Proxy或...Handler接口
  CGLIB（基于类）：没有实现接口,CGLOB是一个第三方库，通过继承方式实现代理、
```

**IOC**控制反转：spring容器创建对象和管理对象的生命周期，bean只需要实例化，控制对象；反转：控制权从自己交给spring容器

**依赖注入：**是一种具体的编程技巧，不通过new的方式在类内部创建类的对象，而是将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递给(注入)类来使用

**依赖倒置：**框架层面（maven）设计;高层模块不依赖底层模块，它们共同依赖一个抽象；抽象不依赖具体的类，具体的类依赖抽象

**AOP的常用注解**

```
@Aspect：用于定义切面，切面类上
@Pointcut:定义切点，标注在方法上，用于指定连接点
@Before
@After
@Around：环绕通知，方法执行前后都通知
@AfterReturning:返回结果后通知
@AfterThrowing：抛出异常后通知
@Advice：通用的通知类型，代替@Before、@After等
```

**反射**

```
1、运行时类访问，运行程序在运行时获取类的完整结构信息
2.动态对象创建 3、动态方法调用 4、访问和修改字段值
  1.加载数据库驱动 Class.forName("com.mysql.cj.jdbc.Driver");  
  2.配置文件加载：IOC容器(动态管理Bean)，Spring通过配置文件配置各种各样的bean,你需要用到哪些bean就配哪些，spring容器根据你的需求去动态加载。
```

**设计一个SpringIoc,怎么考虑？**

```
Bean的生命周期管理
依赖注入
Bean的不同作用域：单例...考虑使用Map来实现不同实例
AOP:动态代理机制和面向切面编程
异常处理机制
注解或配置文件
```

**事务失效的几种情况**

```
未捕获异常：事务中出现了未捕获的异常，异常出现在了事务边界之外，那么事务会失效，数据库回滚
非受检异常：若对非受检异常（RuntimeException及其子类）进行回滚处理，这意味着事务内部方法抛出异常，数据也会回滚
事务传播属性设置不当：事务里边调用事务特别注意
非Public方法
```

** Spring的事务，使用this调用是否生效？**

```
不会生效 spring事务是通过代理对象来控制的，使用this绕过了代理机制；
在一人一单分布式事务中，就是使用
// 索取锁成功，创建代理对象，使用代理对象调用第三方事务方法， 防止事务失效
        IVoucherOrderService proxy = (IVoucherOrderService) AopContext.currentProxy();
```

**Bean的实例化方式**

```
4种：
1.@Component注解标注类，构造方法注入
2.静态工厂：Bean是一个静态方法创建的，而不是直接通过构造方法[private static ClientService=new ClientService();]
3.实例工厂方法，依赖于某个类的实例来创建Bean 
4.FactoryBean接口实例化方法
```

**Bean的生命周期**

```
实例化-属性赋值-初始化-使用-销毁   
```

**SpringMVC的处理流程**

```
1.用户发送请求到前端控制器DispatcherServlet
2.DS收到到请求后调用处理器映射器HandlerMapping
3.HandlerMapping根据请求url找到具体的处理器，将handler和处理器拦截器一并返回给DS
4.DS根据Handler获取handlerAdapter执行handlerAdapter处理一系列操作；如：参数分装，数据格式转换，数据验证等操作
5.执行handler(Controller,页面控制器)
6.handler执行完成返回ModelAndView
7.HandlerAdapter将handler执行结果ModelAndView返回给DS
8.Ds将ModelAndView传给ViewReslove视图解析器
9，ViewReslove解析后返回view
10.DS对view进行渲染视图
11.DS响应客户
```

**HandlerMapping**：将请求映射到处理器（Controller），就是根据URL、请求参数等信息，找到对应的Controller

**HandlerAdapter**：根据Controller处理请求；             mapping找到handler给adapter去处理请求

```
springBoot 自动化配置  快速的项目启动器，引入不同的Starter,可以快速集成常用的框架和库 集成了多种内嵌服务器(tomcat\jetty...)
```

**Mybits比jdbc的好处**

```
好处：sql写在xml文件里，解除 sql 与程序代码的耦合；解耦，提供动态sql语句,并可重用
JDBC流程
1.加载数据库驱动程序
2.建立数据库连接
3.创建statement对象用来执行sql语句
4.执行sql语句
5.处理查询结果
6.关闭资源
```

**SpringCLoud组件**

```
注册中心：发现节点和检查各节点的运行状态
负载均衡
服务通信：一般都是HTTP Rustful风格；SpringCloud中就提供了Feign和RestTemplate两种技术
网络关口
配置管理：集中管理各节点配置文件
统一日志管理：
服务保护：sentinal
```

**服务熔断与服务降级**

```
当某一服务不可用或响应超时的情况时，为防止整个系统出现雪崩，会进行服务熔断，就像是家里的保险丝
释放服务器资源为保证核心业务的流畅
```

**SQL与NoSQL**

```
sql:关系型，一般以二维表的形式
nosql:json、hashMap或其他存储方式
对比：1.ACID与BASE  原子性、一致性、隔离性、持久化VS基本可用，软状态和最终一致性
2.扩展性：nosql数据无关系，易拓展；（Redis复制模式，哨兵模式、。。。
         mysql数据之间有关联；需要解决跨服务器 JOIN，分布式事务等问题
```

**数据库三大范式** 

```
1.要求数据表中的每一列都是不可分割的原子数据项 （一列数据又学院又有班级 不行）
2.在1的条件下，非主属性必需依赖于候选码；消除非主属性对主码的部分函数依赖。（订单：一个产品有多个订单，主键是有订单号和产品号连接而成，但订单金额，订单数据，只于订单号有关，所以分出去）
3.在1与2的条件下，数据表中的每一列数据与主键直接相关，不能间接相关
```

**mysql怎么链表查询**

```
inner join内连接 返回共同的
left join左外连接，返回左表中的所有行，未匹配的有列表会为null
right join右外连接
full join全外连接：mysql不支持，要用union实现 left.. union right..
```

**mysql避免重复插入**

```
union全局唯一性
更新现有的 insert ... on duplicate key update 
忽略因重复插入而导致的插入错误 insert ingore
```

**外键约束**

```
学生表和课程表；查询学生的课程信息，在学生表中设置一个外键course_id；这个外键指向了课程表中的id;保证了数据的完整性与一致性
```

**in的exist**

```
都是用来处理子查询的关键词
in判断左边的表达式是否存在于右边的列表或子查询结果集中 存在返回true
exists用于判断子查询是否能够返回至少一行数据；有返回数据就是true
性能：查询数据较大，exist只有查到数据就返回，in可能会查询整张表
```

**基本函数**

```
字符串函数：Length() Concat() Substring() replace() 数组函数：ABS() 绝对值 power()幂次方
日期和时间：now() curdate() 聚合函数：Sun() count() avg() min() max()
```

```
from -> on -> outer join -> group by -> AGG FUN -> having ->select ->order by->dictinct -> limit 每一个步骤都会形成一张虚拟表 最后一张就是结果
```

```
给学生表、课程成绩表，求不存在01课程但存在02课程的学生的成绩
   NOT EXISTS
select s.sid,s.sname,sc.cid,sc.score from student s Join Score sc On s.sid = sc.sid and sc.cid = '02' where NOT exists
(select 1 from Score sc1 where sc1.sid=s.sid and sc1.cid="01")
  LEFT JOIN AND IS NULL
select s.sid,s.sname,sc.cid,sc.score from student s 
LEFT JOIN Score sc1 ON s.sid = sc1.sid and sc1.cid='01'
LEFT JOIN Score sc2 ON s.sid = sc2.sid and sc2.cid='02'
where sc1.cid is null and sc2.cid is not null;
```

**执行一条sql语句的过程**

```
连接器：建立连接，管理连接，验证用户身份
查询缓存：查询缓存，存在直接返回；8.0已删除
解析sql:对SQL语句进行词法分析、语法分析，形成语法树
执行sql:预处理阶段[表或字段是否存在，将*转化为具体] 优化阶段[考虑查询成本最小的] 执行阶段[执行sql语句；存储引擎读取记录，返回给客户端]
```

**存储引擎**

```
innoDB
MyISAM
```

**InnoDB作为默认引擎**	

```
事务支持：ACID 而 myisam不提供事务支持
并发性能：行级锁机制   myisam只支持表锁，锁粒度较大
崩溃恢复：提供redolog日志实现了奔溃恢复，数据库发生异常情况时(断电)，通过日志恢复数据，保证完整性；myisam没有奔溃恢复
```



**Redis是什么？**k-v存储系统，缓存、事件发布订阅  3点 多种数据结构，方便解决各种问题  内存存储：读写快  持久化

Redis一种支持key-value等多种数据结构的存储系统，可用于缓存(商品缓存)，事件发布订阅[将你关注的人的blog推送]

- 有丰富的数据结构，【不mysql直接处理二维关系数据】，就像我的第二个项目，都是选用不同的数据结构来解决各种问题。（用redis修改session登录，解决tomcat不能共享session的问题；利用sortedSet数据结构，实现排行榜等等）

- 第二个是他的内存存储，数据库的存储有两种，硬盘存储和内存存储，硬盘存储就是将索引存储在内存，数据存储在磁盘上，读取时先在内存中查找索引然后再找值，大量的IO操作磁盘有压力大

  内存存储数据都在内存中，数据读写快

- 持久化功能     他也可以将数据存储到硬盘上，保证数据安全，方便备份和恢复  

  RDB(数据备份文件，快照) 

  AOF(数据追加文件)

**Redis数据结构**

k:String v:[String\Hash\List\Set\SortedSet]

String:存储任何数据，图片序列化对象等 512【项目中验证码的保存，一个月的打卡信息512转化成31个二进制数】

```
1.访问次数，商品浏览次数   用户id为key value是访问次数 命令：incr   频繁访问造成mysql压力，效率低，读取快单线程数据不会乱改
2.缓存用户信息，视频信息(不常修改)，缓存有值在redis上读取，无值在mysql上读取， 用户id为key,v:{用户信息json序列化}过期时间
3.分布式session:session是以文件的形式保存在服务器中，若你的应用做了负载均衡，将网站放在多个服务器上，用户在服务器A上进行登录，session文件写在A服务器，当用户页面跳转，请求被分配到服务器B，找不到session文件，用户要重新登录。实现多个服务器共享一个session,可以将session存放在redis中，数据独立所有应用所在的连接器都是同一个redis服务器。
```

hash:更适合存储对象

```
存储对象，当某个属性需要频繁修改时，不适合用json,每次读取一大段，使用hash可以针对某个属性单独修改。（商品价格）
```

list:简单的字符串排序

set无序集合，集合是通过哈希表实现的，查找删除添加复制度都是1

```
收藏夹（KK音乐中的收藏）点赞
```

sortedset不可重复的有序集，它关联一个score，设置一个分数(可重复的)，项目中我们将时间戳作为score,进行点赞排行，Zrange从高到低排序

```
实时排行榜（点赞排行榜，关注信息推送排行榜）
```

**ZSET**

**持久化**

```
RDB(Redis Database)持久化是把当前内存数据保存成快照保存到磁盘的过程，手动触发（save命令，阻塞redis服务器，rdb完成才会释放），自动触发（自动触发对应的bgsave命令，Redis进程执行fork操作创建子进程，RDB持久化过程由子进程负载，完成后自动结束。阻塞只发生在fork阶段，时间短）在redis.conf配置文件中 [save 秒 修改几次] 后触发,关闭 save ""
```

```
AOF(文件)
```

****

**字符串数字相加，不能使用Integer.ParseInt**

**单点登录**:sso是一种认证机制，允许用户在多个独立系统或应用之间，只需要访问一次就可以访问所有系统和应用；

```
1.用户要访问A系统，在请求被路由到需要认证的页面时，会被重定向到SSO服务器的登录页面
2.用户在SSO服务器上进行登录，登录成功后，SSO服务会生成一个加密票据Token,同时将Token返回给系统或者通过浏览器重定向自动带回
3.A系统接收到Token，通过调用SSo服务器的接口进行token验证，验证成功后，给用户创键会话，并把一部分信息存储到浏览器的Cookie中
4.用户访问B系统时，B系统会检测到用户没有登录，此时重定向到SSO服务器，找到有效的token,直接返回给B系统
5.B系统收到Token后，进行验证，验证通过创建会话，同时也将一部分信息保存到浏览器cookie中
6.接下来用户在各个系统之间进行跳转，只需要带上有效的token，就不需要重新登录
```

****

**缓存穿透**：1.缓存空数据[设置一个较短的过期时间，避免频繁查询数据库] 2.布隆过滤器先进行检查若不存在，直接返回 3.防止非法请求：检查非法请求，封装其IP以及账号

**缓存雪崩**（大量请求同一时间失效   Redis故障）：1.设置不同的过期时间、2.加互斥锁：同一时间只有一个请求3.缓存预热：提前加载缓存数据，避免大量请求落入冷启动  4.使用多级缓存(本地缓存和分布式缓存...)   Redis故障：服务熔断：暂停业务，直接返回错误   建立集群：构建多个Redis集群保证其高效性。

**缓存击穿**：

1.加锁，访问数据库的时候允许一个请求访问，其他请求等待；数据高一致性

2.不给热点数据设置过期时间，设置一个逻辑过期时间，在缓存查询数据的时候查询逻辑过期时间，若到过期，开启另外的线程进行更新，在更新完成之间都返回元数据，最终一致性。

****

**缓存与数据库一致性**

```
六种方式 :
1.先更新缓存再更新数据库
2.先更新数据库存，在更新缓存
3.先删除缓存，再跟新数据库，后续等查询把数据库数据返回到缓存
4.先跟新数据库，再删除缓存，后续等查询把数据库数据返回到缓存  （短期数据不一致，最终一致（不出错的情况下））
5.缓存双删策略。更新数据库之间，删除一次缓存；更新数据库之后，再进行一次延迟删除（避免旧数据被回种）
6.使用Binlog异步更新缓存，监听数据库的binlog变化，通过异步方式更新数据库
[先修改数据库，通过Canal监听数据库的binlog日志，记录数据库的修改数据；通过消息队列异步更新缓存数据；保证缓存中的数据顺序更新，再加上重试机制，避免网络问题导致的更新失败]

前三个不推荐 
```

****

**线程池**（7个关键配置）：池化思想，避免线程的重复创建和销毁

```
ThreadPoolExecutor类的关键配置 
1.核心线程数 2.最大线程数 3.空闲存活时间 4.时间单位 5.工作队列 6.线程工厂 7.拒绝策略
工作原理：
1.默认情况下，线程不会预先创建，只有任务提交后才会创建
2.当核心线程数满了后，不会创建线程，而是加入到工作队列
3.若工作队列满了，才会创建线程达到最大线程数
4.工作队列满了，并且已经达到最大线程数了，这时来的任务就会执行拒绝策略
5.若线程空闲时间超过空闲存活时间，线程数>核心线程数，就会销毁线程直到等于核心线程数
```

**Java并发库中提供了5种常见的线程池**

```
Executors工具类来创建：
1.FixedThreadPool:固定数量 
2.CachedThreadPool:一个可以根据需要创建的新线程工作[没有线程上限，空闲线程在60秒被回收]
3.SingleThreadExecutor:单个线程的线程池
4.ScheduledThreadPool:支持定时任务和周期性任务
5.WorkSrealingPool
```

****

**线程之间如何通信**

```
线程同步机制：
```

